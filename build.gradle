import org.gradle.api.execution.TaskExecutionListener
import org.gradle.api.tasks.testing.Test
import org.gradle.api.tasks.*

apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: 'eclipse'

repositories {
    mavenCentral()
	mavenRepo url:"https://nexus.codehaus.org/content/repositories/snapshots"
}


test {
    if (project.hasProperty('maxParallelForks')) 
        maxParallelForks = project.maxParallelForks as int
    if (project.hasProperty('forkEvery')) 
        forkEvery = project.forkEvery as int


     testLogging.showStandardStreams = true
}

// The drivers we want to use
ext {
    drivers = ["htmlunit"]    
}


dependencies {
	groovy "org.codehaus.groovy:groovy-all:1.8.6"
	
	def gebVersion = "0.6.3"
	def seleniumVersion = "2.0rc3"
	
	// If using Spock, need to depend on geb-spock
	testCompile "org.codehaus.geb:geb-spock:$gebVersion"
	testCompile "org.spockframework:spock-core:0.6-groovy-1.8"
	
	// If using JUnit, need to depend on geb-junit (3 or 4)
	testCompile "org.codehaus.geb:geb-junit4:$gebVersion"
	testCompile "junit:junit-dep:4.8.2"
	
	// Drivers
	drivers.each { driver ->
		testCompile "org.seleniumhq.selenium:selenium-$driver-driver:$seleniumVersion"
	}
}


drivers.each { driver ->
    def testSingle = System.getProperty("test.single")
    if(testSingle)
        System.setProperty("${driver}Test.single", testSingle)
	task "${driver}Test"(type: Test) {
        def grailsWorkDir = new File(buildDir, 'grails-work')
        def projectWorkDir = new File(buildDir, 'project-work')
        def outputDir = new File(buildDir, 'output')

        def appToPort = [:]
        def grailsHome = System.properties['grails.home'] ?: new File('../grails-master').exists() ? new File('../grails-master').absolutePath : new File('../grails-core').absolutePath
        def processes = []
        boolean backgroundComplete = false
        def appsToStart = new File("autostart").listFiles().findAll() { File f -> f.isDirectory() && !f.isHidden()}
        int port = 8890
        for(File appDir in appsToStart) {
            println "Autostarting application $appDir.name"
            if(new File(appDir, "grails-app").exists()) {
                appToPort.put(appDir, port++)
            }
        }

        doFirst {
            [grailsWorkDir, projectWorkDir, outputDir].each {
                it.deleteDir()
                assert it.mkdirs()
            }	
            boolean appsStarted = false            
            for(entry in appToPort) {
                File appDir = entry.key
                port = entry.value
                println "Autostarting application $appDir.name"

                if(new File(appDir, "grails-app").exists()) {
                    // start app
                  
                    appsStarted = true
                    Thread.start {
                        try {
                            def toExecute = buildCommand("upgrade", grailsHome, grailsWorkDir, projectWorkDir, appDir,port)
                            def upgrade = createProcess(toExecute, grailsHome, appDir)
                            executeProcess(upgrade)

                            toExecute = buildCommand("run-app", grailsHome, grailsWorkDir, projectWorkDir, appDir,port)
                            def process = createProcess(toExecute, grailsHome, appDir)
                            processes << process
                            backgroundComplete = true
                            executeProcess(process)
                        }
                        finally {
                           backgroundComplete = true 
                        }
                    }

                }
            }
            if(!appsStarted) {
                backgroundComplete = true
            }

        }

        gradle.addListener(
            [beforeExecute: { org.gradle.api.Task t ->},
             afterExecute: {Task task, TaskState state ->
                 if (task instanceof Test) {
                     while(!backgroundComplete) {
                         sleep 1000
                     }
                     
                     for(Process p in processes) {
                         p.destroy()
                     }
                     
                     processes.clear()
                     [grailsWorkDir, projectWorkDir, outputDir].each {
                         it.deleteDir()
                         assert it.mkdirs()
                     }
                 }
            }] as TaskExecutionListener
        )
        testReportDir = file("$reportsDir/$name/tests")
        testResultsDir = file("$buildDir/test-results/$name")

        for (entry in appToPort) {

            systemProperty "grails.app.port.$entry.key.name", entry.value
        }
        systemProperty "geb.build.reportsDir", "$reportsDir/$name/geb"
        systemProperty "geb.env", driver

        systemProperty 'grailsHome', grailsHome
        systemProperty 'grailsWorkDir',  grailsWorkDir.canonicalPath
        systemProperty 'projectWorkDir',  projectWorkDir.canonicalPath
        systemProperty 'outputDir', outputDir.canonicalPath

//        maxParallelForks = 4
//        forkEvery = 4
		// If you wanted to set the baseUrl in your buildâ€¦
		// systemProperty "geb.build.baseUrl", "http://myapp.com"
	}
}

def executeProcess(Process process) {
    def buffer = new StringBuffer()
    process.consumeProcessOutput(buffer, buffer)
    process.waitForOrKill(1000 * 60 * 5)
    def exitStatus = process.exitValue()
    println buffer
}

Process createProcess(ArrayList<String> toExecute, grailsHome, appDir) {
    println "Running command: ${toExecute.join(' ')}"
    println "Base directory: $appDir"

    def process = (Process) new ProcessBuilder(toExecute).with {
        redirectErrorStream(true)
        directory(appDir.canonicalFile)
        environment()["GRAILS_HOME"] = grailsHome
        start()
    }
    return process
}

def buildCommand(String cmd, grailsHome, grailsWorkDir, projectWorkDir, appDir,int port) {
    [new File("${grailsHome}/bin/grails").canonicalPath, "-Dgrails.work.dir=${grailsWorkDir} -Dgrails.project.work.dir=${projectWorkDir}/${appDir.name}".toString(), "--non-interactive".toString(), "--stacktrace", "-Dgrails.server.port.http=${port}".toString(), cmd.toString()]

}

task test(overwrite: true, dependsOn: drivers.collect { tasks["${it}Test"] })


